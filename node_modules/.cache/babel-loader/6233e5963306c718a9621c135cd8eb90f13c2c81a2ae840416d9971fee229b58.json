{"ast":null,"code":"// src/trace-mapping.ts\nimport { encode, decode } from \"@jridgewell/sourcemap-codec\";\n\n// src/resolve.ts\nimport resolveUri from \"@jridgewell/resolve-uri\";\n\n// src/strip-filename.ts\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\n\n// src/resolve.ts\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return source => resolveUri(prefix + (source || \"\"), from);\n}\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\n\n// src/sort.ts\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const {\n    lastKey,\n    lastNeedle,\n    lastIndex\n  } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/by-source.ts\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(buildNullArray);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex2 = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex2];\n      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      const memo = memos[sourceIndex2];\n      let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  return sources;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction buildNullArray() {\n  return {\n    __proto__: null\n  };\n}\n\n// src/types.ts\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\n\n// src/flatten-map.ts\nvar FlattenMap = function (map, mapUrl) {\n  const parsed = parse(map);\n  if (!(\"sections\" in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const {\n    sections\n  } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const {\n      map,\n      offset\n    } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if (\"sections\" in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const {\n    resolvedSources,\n    sourcesContent: contents,\n    ignoreList: ignores\n  } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    if (lineI > stopLine) return;\n    const out = getLine(mappings, lineI);\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nvar TraceMap = class {\n  constructor(map, mapUrl) {\n    const isString = typeof map === \"string\";\n    if (!isString && map._decodedMemo) return map;\n    const parsed = parse(map);\n    const {\n      version,\n      file,\n      names,\n      sourceRoot,\n      sources,\n      sourcesContent\n    } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n    const {\n      mappings\n    } = parsed;\n    if (typeof mappings === \"string\") {\n      this._encoded = mappings;\n      this._decoded = void 0;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = void 0;\n      this._decoded = maybeSort(mappings, isString);\n    } else if (parsed.sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = void 0;\n    this._bySourceMemos = void 0;\n  }\n};\nfunction cast(map) {\n  return map;\n}\nfunction encodedMappings(map) {\n  var _a, _b;\n  return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = encode(cast(map)._decoded);\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));\n}\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n  return index === -1 ? null : segments[index];\n}\nfunction originalPositionFor(map, needle) {\n  let {\n    line,\n    column,\n    bias\n  } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\nfunction generatedPositionFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\nfunction allGeneratedPositionsFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\nfunction sourceContentFor(map, source) {\n  const {\n    sourcesContent\n  } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\nfunction isIgnored(map, source) {\n  const {\n    ignoreList\n  } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return {\n    source,\n    line,\n    column,\n    name\n  };\n}\nfunction GMapping(line, column) {\n  return {\n    line,\n    column\n  };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let sourceIndex2 = sources.indexOf(source);\n  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);\n  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);\n  const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));\n  const segments = generated[sourceIndex2][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = cast(map)._bySourceMemos[sourceIndex2];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\nexport { FlattenMap as AnyMap, FlattenMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, isIgnored, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":{"version":3,"names":["encode","decode","resolveUri","stripFilename","path","index","lastIndexOf","slice","resolver","mapUrl","sourceRoot","from","prefix","source","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex2","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","parse","JSON","FlattenMap","parsed","TraceMap","sourcesContent","names","ignoreList","recurse","Infinity","joined","version","file","presortedDecodedMap","input","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","ignores","append","push","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","constructor","isString","_decodedMemo","x_google_ignoreList","resolve","_encoded","_decoded","Array","isArray","Error","stringify","_bySources","_bySourceMemos","cast","encodedMappings","_a","_b","traceSegment","segments","traceSegmentInternal","originalPositionFor","bias","OMapping","segment","generatedPositionFor","generatedPosition","allGeneratedPositionsFor","eachMapping","cb","generatedLine","generatedColumn","originalColumn","name","sourceIndex","indexOf","sourceContentFor","isIgnored","includes","tracer","clone","decodedMap","encodedMap","GMapping","sliceGeneratedPositions","matchedColumn","max","result","all","generated"],"sources":["E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\trace-mapping.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\resolve.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\strip-filename.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sourcemap-segment.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sort.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\binary-search.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\by-source.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\types.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\flatten-map.ts"],"sourcesContent":["import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolver from './resolve';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n  XInput,\n  SectionedSourceMap,\n  Ro,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMap,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Section,\n  SectionedSourceMap,\n  SourceMapV3,\n  Bias,\n  EachMapping,\n  GeneratedMapping,\n  InvalidGeneratedMapping,\n  InvalidOriginalMapping,\n  Needle,\n  OriginalMapping,\n  OriginalMapping as Mapping,\n  SectionedSourceMapInput,\n  SourceMapInput,\n  SourceNeedle,\n  XInput,\n  EncodedSourceMapXInput,\n  DecodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionXInput,\n} from './types';\n\ninterface PublicMap {\n  _encoded: TraceMap['_encoded'];\n  _decoded: TraceMap['_decoded'];\n  _decodedMemo: TraceMap['_decodedMemo'];\n  _bySources: TraceMap['_bySources'];\n  _bySourceMemos: TraceMap['_bySourceMemos'];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\nexport { FlattenMap, FlattenMap as AnyMap } from './flatten-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n\n  declare resolvedSources: string[];\n  declare private _encoded: string | undefined;\n\n  declare private _decoded: SourceMapSegment[][] | undefined;\n  declare private _decodedMemo: MemoState;\n\n  declare private _bySources: Source[] | undefined;\n  declare private _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: Ro<SourceMapInput>, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = parse(map as Exclude<SourceMapInput, TraceMap>);\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\n\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    } else if ((parsed as unknown as SectionedSourceMap).sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\n}\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\n}\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport function traceSegment(\n  map: TraceMap,\n  line: number,\n  column: number,\n): Readonly<SourceMapSegment> | null {\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND,\n  );\n\n  return index === -1 ? null : segments[index];\n}\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport function originalPositionFor(\n  map: TraceMap,\n  needle: Needle,\n): OriginalMapping | InvalidOriginalMapping {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND,\n  );\n\n  if (index === -1) return OMapping(null, null, null, null);\n\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n  );\n}\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport function generatedPositionFor(\n  map: TraceMap,\n  needle: SourceNeedle,\n): GeneratedMapping | InvalidGeneratedMapping {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\n  const { source, line, column, bias } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name,\n      } as EachMapping);\n    }\n  }\n}\n\nfunction sourceIndex(map: TraceMap, source: string): number {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nexport function isIgnored(map: TraceMap, source: string): boolean {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function decodedMap(\n  map: TraceMap,\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\n  return clone(map, decodedMappings(map));\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\n  return clone(map, encodedMappings(map));\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: false,\n): GeneratedMapping | InvalidGeneratedMapping;\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: true,\n): GeneratedMapping[];\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: boolean,\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const { sources, resolvedSources } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n  const generated = (cast(map)._bySources ||= buildBySources(\n    decodedMappings(map),\n    (cast(map)._bySourceMemos = sources.map(memoizedState)),\n  ));\n\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n\n  const memo = cast(map)._bySourceMemos![sourceIndex];\n\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n","import resolveUri from '@jridgewell/resolve-uri';\nimport stripFilename from './strip-filename';\n\ntype Resolve = (source: string | null) => string;\nexport default function resolver(\n  mapUrl: string | null | undefined,\n  sourceRoot: string | undefined,\n): Resolve {\n  const from = stripFilename(mapUrl);\n  // The sourceRoot is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  const prefix = sourceRoot ? sourceRoot + '/' : '';\n\n  return (source) => resolveUri(prefix + (source || ''), from);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      let index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import type { SourceMapSegment } from './sourcemap-segment';\nimport type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping';\n\nexport interface SourceMapV3 {\n  file?: string | null;\n  names: string[];\n  sourceRoot?: string;\n  sources: (string | null)[];\n  sourcesContent?: (string | null)[];\n  version: 3;\n  ignoreList?: number[];\n}\n\nexport interface EncodedSourceMap extends SourceMapV3 {\n  mappings: string;\n}\n\nexport interface DecodedSourceMap extends SourceMapV3 {\n  mappings: SourceMapSegment[][];\n}\n\nexport interface Section {\n  offset: { line: number; column: number };\n  map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;\n}\n\nexport interface SectionedSourceMap {\n  file?: string | null;\n  sections: Section[];\n  version: 3;\n}\n\nexport type OriginalMapping = {\n  source: string | null;\n  line: number;\n  column: number;\n  name: string | null;\n};\n\nexport type InvalidOriginalMapping = {\n  source: null;\n  line: null;\n  column: null;\n  name: null;\n};\n\nexport type GeneratedMapping = {\n  line: number;\n  column: number;\n};\nexport type InvalidGeneratedMapping = {\n  line: null;\n  column: null;\n};\n\nexport type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;\n\nexport type XInput = { x_google_ignoreList?: SourceMapV3['ignoreList'] };\nexport type EncodedSourceMapXInput = EncodedSourceMap & XInput;\nexport type DecodedSourceMapXInput = DecodedSourceMap & XInput;\nexport type SectionedSourceMapXInput = Omit<SectionedSourceMap, 'sections'> & {\n  sections: SectionXInput[];\n};\nexport type SectionXInput = Omit<Section, 'map'> & {\n  map: SectionedSourceMapInput;\n};\n\nexport type SourceMapInput = string | EncodedSourceMapXInput | DecodedSourceMapXInput | TraceMap;\nexport type SectionedSourceMapInput = SourceMapInput | SectionedSourceMapXInput;\n\nexport type Needle = { line: number; column: number; bias?: Bias };\nexport type SourceNeedle = { source: string; line: number; column: number; bias?: Bias };\n\nexport type EachMapping =\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: null;\n      originalLine: null;\n      originalColumn: null;\n      name: null;\n    }\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: string | null;\n      originalLine: number;\n      originalColumn: number;\n      name: string | null;\n    };\n\nexport abstract class SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare resolvedSources: SourceMapV3['sources'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n}\n\nexport type Ro<T> =\n  T extends Array<infer V>\n    ? V[] | Readonly<V[]> | RoArray<V> | Readonly<RoArray<V>>\n    : T extends object\n      ? T | Readonly<T> | RoObject<T> | Readonly<RoObject<T>>\n      : T;\ntype RoArray<T> = Ro<T>[];\ntype RoObject<T> = { [K in keyof T]: T[K] | Ro<T[K]> };\n\nexport function parse<T>(map: T): Exclude<T, string> {\n  return typeof map === 'string' ? JSON.parse(map) : (map as Exclude<T, string>);\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type {\n  DecodedSourceMap,\n  DecodedSourceMapXInput,\n  EncodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionedSourceMapInput,\n  SectionXInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype FlattenMap = {\n  new (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n  (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n};\n\nexport const FlattenMap: FlattenMap = function (map, mapUrl) {\n  const parsed = parse(map as SectionedSourceMapInput);\n\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\n  }\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const ignoreList: number[] = [];\n\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity,\n  );\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList,\n  };\n\n  return presortedDecodedMap(joined);\n} as FlattenMap;\n\nfunction recurse(\n  input: SectionedSourceMapXInput,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: SectionXInput['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n"],"mappings":";AAAA,SAASA,MAAA,EAAQC,MAAA,QAAc;;;ACA/B,OAAOC,UAAA,MAAgB;;;ACGR,SAARC,cAA+BC,IAAA,EAAyC;EAC7E,IAAI,CAACA,IAAA,EAAM,OAAO;EAClB,MAAMC,KAAA,GAAQD,IAAA,CAAKE,WAAA,CAAY,GAAG;EAClC,OAAOF,IAAA,CAAKG,KAAA,CAAM,GAAGF,KAAA,GAAQ,CAAC;AAChC;;;ADHe,SAARG,SACLC,MAAA,EACAC,UAAA,EACS;EACT,MAAMC,IAAA,GAAOR,aAAA,CAAcM,MAAM;EAIjC,MAAMG,MAAA,GAASF,UAAA,GAAaA,UAAA,GAAa,MAAM;EAE/C,OAAQG,MAAA,IAAWX,UAAA,CAAWU,MAAA,IAAUC,MAAA,IAAU,KAAKF,IAAI;AAC7D;;;AEAO,IAAMG,MAAA,GAAS;AACf,IAAMC,aAAA,GAAgB;AACtB,IAAMC,WAAA,GAAc;AACpB,IAAMC,aAAA,GAAgB;AACtB,IAAMC,WAAA,GAAc;AAEpB,IAAMC,kBAAA,GAAqB;AAC3B,IAAMC,oBAAA,GAAuB;;;AClBrB,SAARC,UACLC,QAAA,EACAC,KAAA,EACsB;EACtB,MAAMC,aAAA,GAAgBC,uBAAA,CAAwBH,QAAA,EAAU,CAAC;EACzD,IAAIE,aAAA,KAAkBF,QAAA,CAASI,MAAA,EAAQ,OAAOJ,QAAA;EAI9C,IAAI,CAACC,KAAA,EAAOD,QAAA,GAAWA,QAAA,CAASf,KAAA,CAAM;EAEtC,SAASoB,CAAA,GAAIH,aAAA,EAAeG,CAAA,GAAIL,QAAA,CAASI,MAAA,EAAQC,CAAA,GAAIF,uBAAA,CAAwBH,QAAA,EAAUK,CAAA,GAAI,CAAC,GAAG;IAC7FL,QAAA,CAASK,CAAC,IAAIC,YAAA,CAAaN,QAAA,CAASK,CAAC,GAAGJ,KAAK;EAC/C;EACA,OAAOD,QAAA;AACT;AAEA,SAASG,wBAAwBH,QAAA,EAAgCO,KAAA,EAAuB;EACtF,SAASF,CAAA,GAAIE,KAAA,EAAOF,CAAA,GAAIL,QAAA,CAASI,MAAA,EAAQC,CAAA,IAAK;IAC5C,IAAI,CAACG,QAAA,CAASR,QAAA,CAASK,CAAC,CAAC,GAAG,OAAOA,CAAA;EACrC;EACA,OAAOL,QAAA,CAASI,MAAA;AAClB;AAEA,SAASI,SAASC,IAAA,EAAmC;EACnD,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAID,IAAA,CAAKL,MAAA,EAAQM,CAAA,IAAK;IACpC,IAAID,IAAA,CAAKC,CAAC,EAAElB,MAAM,IAAIiB,IAAA,CAAKC,CAAA,GAAI,CAAC,EAAElB,MAAM,GAAG;MACzC,OAAO;IACT;EACF;EACA,OAAO;AACT;AAEA,SAASc,aAAaG,IAAA,EAA0BR,KAAA,EAAoC;EAClF,IAAI,CAACA,KAAA,EAAOQ,IAAA,GAAOA,IAAA,CAAKxB,KAAA,CAAM;EAC9B,OAAOwB,IAAA,CAAKE,IAAA,CAAKC,cAAc;AACjC;AAEA,SAASA,eAAeC,CAAA,EAAqBC,CAAA,EAA6B;EACxE,OAAOD,CAAA,CAAErB,MAAM,IAAIsB,CAAA,CAAEtB,MAAM;AAC7B;;;ACnCO,IAAIuB,KAAA,GAAQ;AAkBZ,SAASC,aACdC,QAAA,EACAC,MAAA,EACAC,GAAA,EACAC,IAAA,EACQ;EACR,OAAOD,GAAA,IAAOC,IAAA,EAAM;IAClB,MAAMC,GAAA,GAAMF,GAAA,IAAQC,IAAA,GAAOD,GAAA,IAAQ;IACnC,MAAMG,GAAA,GAAML,QAAA,CAASI,GAAG,EAAE7B,MAAM,IAAI0B,MAAA;IAEpC,IAAII,GAAA,KAAQ,GAAG;MACbP,KAAA,GAAQ;MACR,OAAOM,GAAA;IACT;IAEA,IAAIC,GAAA,GAAM,GAAG;MACXH,GAAA,GAAME,GAAA,GAAM;IACd,OAAO;MACLD,IAAA,GAAOC,GAAA,GAAM;IACf;EACF;EAEAN,KAAA,GAAQ;EACR,OAAOI,GAAA,GAAM;AACf;AAEO,SAASI,WACdN,QAAA,EACAC,MAAA,EACAnC,KAAA,EACQ;EACR,SAASsB,CAAA,GAAItB,KAAA,GAAQ,GAAGsB,CAAA,GAAIY,QAAA,CAASb,MAAA,EAAQrB,KAAA,GAAQsB,CAAA,IAAK;IACxD,IAAIY,QAAA,CAASZ,CAAC,EAAEb,MAAM,MAAM0B,MAAA,EAAQ;EACtC;EACA,OAAOnC,KAAA;AACT;AAEO,SAASyC,WACdP,QAAA,EACAC,MAAA,EACAnC,KAAA,EACQ;EACR,SAASsB,CAAA,GAAItB,KAAA,GAAQ,GAAGsB,CAAA,IAAK,GAAGtB,KAAA,GAAQsB,CAAA,IAAK;IAC3C,IAAIY,QAAA,CAASZ,CAAC,EAAEb,MAAM,MAAM0B,MAAA,EAAQ;EACtC;EACA,OAAOnC,KAAA;AACT;AAEO,SAAS0C,cAAA,EAA2B;EACzC,OAAO;IACLC,OAAA,EAAS;IACTC,UAAA,EAAY;IACZC,SAAA,EAAW;EACb;AACF;AAMO,SAASC,qBACdZ,QAAA,EACAC,MAAA,EACAY,KAAA,EACAC,GAAA,EACQ;EACR,MAAM;IAAEL,OAAA;IAASC,UAAA;IAAYC;EAAU,IAAIE,KAAA;EAE3C,IAAIX,GAAA,GAAM;EACV,IAAIC,IAAA,GAAOH,QAAA,CAASb,MAAA,GAAS;EAC7B,IAAI2B,GAAA,KAAQL,OAAA,EAAS;IACnB,IAAIR,MAAA,KAAWS,UAAA,EAAY;MACzBZ,KAAA,GAAQa,SAAA,KAAc,MAAMX,QAAA,CAASW,SAAS,EAAEpC,MAAM,MAAM0B,MAAA;MAC5D,OAAOU,SAAA;IACT;IAEA,IAAIV,MAAA,IAAUS,UAAA,EAAY;MAExBR,GAAA,GAAMS,SAAA,KAAc,KAAK,IAAIA,SAAA;IAC/B,OAAO;MACLR,IAAA,GAAOQ,SAAA;IACT;EACF;EACAE,KAAA,CAAMJ,OAAA,GAAUK,GAAA;EAChBD,KAAA,CAAMH,UAAA,GAAaT,MAAA;EAEnB,OAAQY,KAAA,CAAMF,SAAA,GAAYZ,YAAA,CAAaC,QAAA,EAAUC,MAAA,EAAQC,GAAA,EAAKC,IAAI;AACpE;;;ACrGe,SAARY,eACLC,OAAA,EACAC,KAAA,EACU;EACV,MAAMC,OAAA,GAAoBD,KAAA,CAAME,GAAA,CAAIC,cAAc;EAElD,SAAShC,CAAA,GAAI,GAAGA,CAAA,GAAI4B,OAAA,CAAQ7B,MAAA,EAAQC,CAAA,IAAK;IACvC,MAAMI,IAAA,GAAOwB,OAAA,CAAQ5B,CAAC;IACtB,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAID,IAAA,CAAKL,MAAA,EAAQM,CAAA,IAAK;MACpC,MAAM4B,GAAA,GAAM7B,IAAA,CAAKC,CAAC;MAClB,IAAI4B,GAAA,CAAIlC,MAAA,KAAW,GAAG;MAEtB,MAAMmC,YAAA,GAAcD,GAAA,CAAI7C,aAAa;MACrC,MAAM+C,UAAA,GAAaF,GAAA,CAAI5C,WAAW;MAClC,MAAM+C,YAAA,GAAeH,GAAA,CAAI3C,aAAa;MACtC,MAAM+C,cAAA,GAAiBP,OAAA,CAAQI,YAAW;MAC1C,MAAMI,YAAA,GAAgBD,cAAA,CAAAF,UAAA,MAAAE,cAAA,CAAAF,UAAA,IAA+B,EAAC;MACtD,MAAMI,IAAA,GAAOV,KAAA,CAAMK,YAAW;MAM9B,IAAIxD,KAAA,GAAQwC,UAAA,CACVoB,YAAA,EACAF,YAAA,EACAZ,oBAAA,CAAqBc,YAAA,EAAcF,YAAA,EAAcG,IAAA,EAAMJ,UAAU,CACnE;MAEAI,IAAA,CAAKhB,SAAA,GAAY,EAAE7C,KAAA;MACnB8D,MAAA,CAAOF,YAAA,EAAc5D,KAAA,EAAO,CAAC0D,YAAA,EAAcpC,CAAA,EAAGiC,GAAA,CAAI9C,MAAM,CAAC,CAAC;IAC5D;EACF;EAEA,OAAO2C,OAAA;AACT;AAEA,SAASU,OAAUC,KAAA,EAAY/D,KAAA,EAAegE,KAAA,EAAU;EACtD,SAAS1C,CAAA,GAAIyC,KAAA,CAAM1C,MAAA,EAAQC,CAAA,GAAItB,KAAA,EAAOsB,CAAA,IAAK;IACzCyC,KAAA,CAAMzC,CAAC,IAAIyC,KAAA,CAAMzC,CAAA,GAAI,CAAC;EACxB;EACAyC,KAAA,CAAM/D,KAAK,IAAIgE,KAAA;AACjB;AAOA,SAASV,eAAA,EAAmD;EAC1D,OAAO;IAAEW,SAAA,EAAW;EAAK;AAC3B;;;AC+CO,SAASC,MAASb,GAAA,EAA4B;EACnD,OAAO,OAAOA,GAAA,KAAQ,WAAWc,IAAA,CAAKD,KAAA,CAAMb,GAAG,IAAKA,GAAA;AACtD;;;ACvFO,IAAMe,UAAA,GAAyB,SAAAA,CAAUf,GAAA,EAAKjD,MAAA,EAAQ;EAC3D,MAAMiE,MAAA,GAASH,KAAA,CAAMb,GAA8B;EAEnD,IAAI,EAAE,cAAcgB,MAAA,GAAS;IAC3B,OAAO,IAAIC,QAAA,CAASD,MAAA,EAA2DjE,MAAM;EACvF;EAEA,MAAMa,QAAA,GAAiC,EAAC;EACxC,MAAMmC,OAAA,GAAoB,EAAC;EAC3B,MAAMmB,cAAA,GAAoC,EAAC;EAC3C,MAAMC,KAAA,GAAkB,EAAC;EACzB,MAAMC,UAAA,GAAuB,EAAC;EAE9BC,OAAA,CACEL,MAAA,EACAjE,MAAA,EACAa,QAAA,EACAmC,OAAA,EACAmB,cAAA,EACAC,KAAA,EACAC,UAAA,EACA,GACA,GACAE,QAAA,EACAA,QACF;EAEA,MAAMC,MAAA,GAA2B;IAC/BC,OAAA,EAAS;IACTC,IAAA,EAAMT,MAAA,CAAOS,IAAA;IACbN,KAAA;IACApB,OAAA;IACAmB,cAAA;IACAtD,QAAA;IACAwD;EACF;EAEA,OAAOM,mBAAA,CAAoBH,MAAM;AACnC;AAEA,SAASF,QACPM,KAAA,EACA5E,MAAA,EACAa,QAAA,EACAmC,OAAA,EACAmB,cAAA,EACAC,KAAA,EACAC,UAAA,EACAQ,UAAA,EACAC,YAAA,EACAC,QAAA,EACAC,UAAA,EACA;EACA,MAAM;IAAEC;EAAS,IAAIL,KAAA;EACrB,SAAS1D,CAAA,GAAI,GAAGA,CAAA,GAAI+D,QAAA,CAAShE,MAAA,EAAQC,CAAA,IAAK;IACxC,MAAM;MAAE+B,GAAA;MAAKiC;IAAO,IAAID,QAAA,CAAS/D,CAAC;IAElC,IAAIiE,EAAA,GAAKJ,QAAA;IACT,IAAIK,EAAA,GAAKJ,UAAA;IACT,IAAI9D,CAAA,GAAI,IAAI+D,QAAA,CAAShE,MAAA,EAAQ;MAC3B,MAAMoE,UAAA,GAAaJ,QAAA,CAAS/D,CAAA,GAAI,CAAC,EAAEgE,MAAA;MACnCC,EAAA,GAAKG,IAAA,CAAKC,GAAA,CAAIR,QAAA,EAAUF,UAAA,GAAaQ,UAAA,CAAW/D,IAAI;MAEpD,IAAI6D,EAAA,KAAOJ,QAAA,EAAU;QACnBK,EAAA,GAAKE,IAAA,CAAKC,GAAA,CAAIP,UAAA,EAAYF,YAAA,GAAeO,UAAA,CAAWG,MAAM;MAC5D,WAAWL,EAAA,GAAKJ,QAAA,EAAU;QACxBK,EAAA,GAAKN,YAAA,GAAeO,UAAA,CAAWG,MAAA;MACjC;IACF;IAEAC,UAAA,CACExC,GAAA,EACAjD,MAAA,EACAa,QAAA,EACAmC,OAAA,EACAmB,cAAA,EACAC,KAAA,EACAC,UAAA,EACAQ,UAAA,GAAaK,MAAA,CAAO5D,IAAA,EACpBwD,YAAA,GAAeI,MAAA,CAAOM,MAAA,EACtBL,EAAA,EACAC,EACF;EACF;AACF;AAEA,SAASK,WACPb,KAAA,EACA5E,MAAA,EACAa,QAAA,EACAmC,OAAA,EACAmB,cAAA,EACAC,KAAA,EACAC,UAAA,EACAQ,UAAA,EACAC,YAAA,EACAC,QAAA,EACAC,UAAA,EACA;EACA,MAAMf,MAAA,GAASH,KAAA,CAAMc,KAAK;EAC1B,IAAI,cAAcX,MAAA,EAAQ,OAAOK,OAAA,CAAQ,GAAIoB,SAAmD;EAEhG,MAAMzC,GAAA,GAAM,IAAIiB,QAAA,CAASD,MAAA,EAAQjE,MAAM;EACvC,MAAM2F,aAAA,GAAgB3C,OAAA,CAAQ/B,MAAA;EAC9B,MAAM2E,WAAA,GAAcxB,KAAA,CAAMnD,MAAA;EAC1B,MAAM6B,OAAA,GAAU+C,eAAA,CAAgB5C,GAAG;EACnC,MAAM;IAAE6C,eAAA;IAAiB3B,cAAA,EAAgB4B,QAAA;IAAU1B,UAAA,EAAY2B;EAAQ,IAAI/C,GAAA;EAE3EgD,MAAA,CAAOjD,OAAA,EAAS8C,eAAe;EAC/BG,MAAA,CAAO7B,KAAA,EAAOnB,GAAA,CAAImB,KAAK;EAEvB,IAAI2B,QAAA,EAAUE,MAAA,CAAO9B,cAAA,EAAgB4B,QAAQ,OACxC,SAAS7E,CAAA,GAAI,GAAGA,CAAA,GAAI4E,eAAA,CAAgB7E,MAAA,EAAQC,CAAA,IAAKiD,cAAA,CAAe+B,IAAA,CAAK,IAAI;EAE9E,IAAIF,OAAA,EAAS,SAAS9E,CAAA,GAAI,GAAGA,CAAA,GAAI8E,OAAA,CAAQ/E,MAAA,EAAQC,CAAA,IAAKmD,UAAA,CAAW6B,IAAA,CAAKF,OAAA,CAAQ9E,CAAC,IAAIyE,aAAa;EAEhG,SAASzE,CAAA,GAAI,GAAGA,CAAA,GAAI4B,OAAA,CAAQ7B,MAAA,EAAQC,CAAA,IAAK;IACvC,MAAMiF,KAAA,GAAQtB,UAAA,GAAa3D,CAAA;IAM3B,IAAIiF,KAAA,GAAQpB,QAAA,EAAU;IAItB,MAAMqB,GAAA,GAAMC,OAAA,CAAQxF,QAAA,EAAUsF,KAAK;IAGnC,MAAMG,OAAA,GAAUpF,CAAA,KAAM,IAAI4D,YAAA,GAAe;IAEzC,MAAMxD,IAAA,GAAOwB,OAAA,CAAQ5B,CAAC;IACtB,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAID,IAAA,CAAKL,MAAA,EAAQM,CAAA,IAAK;MACpC,MAAM4B,GAAA,GAAM7B,IAAA,CAAKC,CAAC;MAClB,MAAMiE,MAAA,GAASc,OAAA,GAAUnD,GAAA,CAAI9C,MAAM;MAInC,IAAI8F,KAAA,KAAUpB,QAAA,IAAYS,MAAA,IAAUR,UAAA,EAAY;MAEhD,IAAI7B,GAAA,CAAIlC,MAAA,KAAW,GAAG;QACpBmF,GAAA,CAAIF,IAAA,CAAK,CAACV,MAAM,CAAC;QACjB;MACF;MAEA,MAAMe,YAAA,GAAeZ,aAAA,GAAgBxC,GAAA,CAAI7C,aAAa;MACtD,MAAM+C,UAAA,GAAaF,GAAA,CAAI5C,WAAW;MAClC,MAAM+C,YAAA,GAAeH,GAAA,CAAI3C,aAAa;MACtC4F,GAAA,CAAIF,IAAA,CACF/C,GAAA,CAAIlC,MAAA,KAAW,IACX,CAACuE,MAAA,EAAQe,YAAA,EAAclD,UAAA,EAAYC,YAAY,IAC/C,CAACkC,MAAA,EAAQe,YAAA,EAAclD,UAAA,EAAYC,YAAA,EAAcsC,WAAA,GAAczC,GAAA,CAAI1C,WAAW,CAAC,CACrF;IACF;EACF;AACF;AAEA,SAASwF,OAAUO,GAAA,EAAUC,KAAA,EAAY;EACvC,SAASvF,CAAA,GAAI,GAAGA,CAAA,GAAIuF,KAAA,CAAMxF,MAAA,EAAQC,CAAA,IAAKsF,GAAA,CAAIN,IAAA,CAAKO,KAAA,CAAMvF,CAAC,CAAC;AAC1D;AAEA,SAASmF,QAAWG,GAAA,EAAY5G,KAAA,EAAoB;EAClD,SAASsB,CAAA,GAAIsF,GAAA,CAAIvF,MAAA,EAAQC,CAAA,IAAKtB,KAAA,EAAOsB,CAAA,IAAKsF,GAAA,CAAItF,CAAC,IAAI,EAAC;EACpD,OAAOsF,GAAA,CAAI5G,KAAK;AAClB;;;ARhHA,IAAM8G,aAAA,GAAgB;AACtB,IAAMC,eAAA,GAAkB;AAEjB,IAAMC,iBAAA,GAAoB;AAC1B,IAAMC,oBAAA,GAAuB;AAI7B,IAAM3C,QAAA,GAAN,MAAoC;EAkBzC4C,YAAY7D,GAAA,EAAyBjD,MAAA,EAAwB;IAC3D,MAAM+G,QAAA,GAAW,OAAO9D,GAAA,KAAQ;IAChC,IAAI,CAAC8D,QAAA,IAAa9D,GAAA,CAAyC+D,YAAA,EAAc,OAAO/D,GAAA;IAEhF,MAAMgB,MAAA,GAASH,KAAA,CAAMb,GAAwC;IAE7D,MAAM;MAAEwB,OAAA;MAASC,IAAA;MAAMN,KAAA;MAAOnE,UAAA;MAAY+C,OAAA;MAASmB;IAAe,IAAIF,MAAA;IACtE,KAAKQ,OAAA,GAAUA,OAAA;IACf,KAAKC,IAAA,GAAOA,IAAA;IACZ,KAAKN,KAAA,GAAQA,KAAA,IAAS,EAAC;IACvB,KAAKnE,UAAA,GAAaA,UAAA;IAClB,KAAK+C,OAAA,GAAUA,OAAA;IACf,KAAKmB,cAAA,GAAiBA,cAAA;IACtB,KAAKE,UAAA,GAAaJ,MAAA,CAAOI,UAAA,IAAeJ,MAAA,CAAkBgD,mBAAA,IAAuB;IAEjF,MAAMC,OAAA,GAAUnH,QAAA,CAASC,MAAA,EAAQC,UAAU;IAC3C,KAAK6F,eAAA,GAAkB9C,OAAA,CAAQC,GAAA,CAAIiE,OAAO;IAE1C,MAAM;MAAErG;IAAS,IAAIoD,MAAA;IACrB,IAAI,OAAOpD,QAAA,KAAa,UAAU;MAChC,KAAKsG,QAAA,GAAWtG,QAAA;MAChB,KAAKuG,QAAA,GAAW;IAClB,WAAWC,KAAA,CAAMC,OAAA,CAAQzG,QAAQ,GAAG;MAClC,KAAKsG,QAAA,GAAW;MAChB,KAAKC,QAAA,GAAWxG,SAAA,CAAUC,QAAA,EAAUkG,QAAQ;IAC9C,WAAY9C,MAAA,CAAyCgB,QAAA,EAAU;MAC7D,MAAM,IAAIsC,KAAA,CAAM,4EAA4E;IAC9F,OAAO;MACL,MAAM,IAAIA,KAAA,CAAM,uBAAuBxD,IAAA,CAAKyD,SAAA,CAAUvD,MAAM,CAAC,EAAE;IACjE;IAEA,KAAK+C,YAAA,GAAe1E,aAAA,CAAc;IAClC,KAAKmF,UAAA,GAAa;IAClB,KAAKC,cAAA,GAAiB;EACxB;AACF;AAMA,SAASC,KAAK1E,GAAA,EAAyB;EACrC,OAAOA,GAAA;AACT;AAKO,SAAS2E,gBAAgB3E,GAAA,EAA6C;EAzJ7E,IAAA4E,EAAA,EAAAC,EAAA;EA0JE,QAAQA,EAAA,IAAAD,EAAA,GAAAF,IAAA,CAAK1E,GAAG,GAAEkE,QAAA,KAAV,OAAAW,EAAA,GAAAD,EAAA,CAAUV,QAAA,GAAa5H,MAAA,CAAOoI,IAAA,CAAK1E,GAAG,EAAEmE,QAAS;AAC3D;AAKO,SAASvB,gBAAgB5C,GAAA,EAAuD;EAhKvF,IAAA4E,EAAA;EAiKE,QAAQA,EAAA,GAAAF,IAAA,CAAK1E,GAAG,GAAEmE,QAAA,KAAVS,EAAA,CAAUT,QAAA,GAAa5H,MAAA,CAAOmI,IAAA,CAAK1E,GAAG,EAAEkE,QAAS;AAC3D;AAMO,SAASY,aACd9E,GAAA,EACA3B,IAAA,EACAkE,MAAA,EACmC;EACnC,MAAM1C,OAAA,GAAU+C,eAAA,CAAgB5C,GAAG;EAInC,IAAI3B,IAAA,IAAQwB,OAAA,CAAQ7B,MAAA,EAAQ,OAAO;EAEnC,MAAM+G,QAAA,GAAWlF,OAAA,CAAQxB,IAAI;EAC7B,MAAM1B,KAAA,GAAQqI,oBAAA,CACZD,QAAA,EACAL,IAAA,CAAK1E,GAAG,EAAE+D,YAAA,EACV1F,IAAA,EACAkE,MAAA,EACAqB,oBACF;EAEA,OAAOjH,KAAA,KAAU,KAAK,OAAOoI,QAAA,CAASpI,KAAK;AAC7C;AAOO,SAASsI,oBACdjF,GAAA,EACAlB,MAAA,EAC0C;EAC1C,IAAI;IAAET,IAAA;IAAMkE,MAAA;IAAQ2C;EAAK,IAAIpG,MAAA;EAC7BT,IAAA;EACA,IAAIA,IAAA,GAAO,GAAG,MAAM,IAAIiG,KAAA,CAAMb,aAAa;EAC3C,IAAIlB,MAAA,GAAS,GAAG,MAAM,IAAI+B,KAAA,CAAMZ,eAAe;EAE/C,MAAM7D,OAAA,GAAU+C,eAAA,CAAgB5C,GAAG;EAInC,IAAI3B,IAAA,IAAQwB,OAAA,CAAQ7B,MAAA,EAAQ,OAAOmH,QAAA,CAAS,MAAM,MAAM,MAAM,IAAI;EAElE,MAAMJ,QAAA,GAAWlF,OAAA,CAAQxB,IAAI;EAC7B,MAAM1B,KAAA,GAAQqI,oBAAA,CACZD,QAAA,EACAL,IAAA,CAAK1E,GAAG,EAAE+D,YAAA,EACV1F,IAAA,EACAkE,MAAA,EACA2C,IAAA,IAAQtB,oBACV;EAEA,IAAIjH,KAAA,KAAU,IAAI,OAAOwI,QAAA,CAAS,MAAM,MAAM,MAAM,IAAI;EAExD,MAAMC,OAAA,GAAUL,QAAA,CAASpI,KAAK;EAC9B,IAAIyI,OAAA,CAAQpH,MAAA,KAAW,GAAG,OAAOmH,QAAA,CAAS,MAAM,MAAM,MAAM,IAAI;EAEhE,MAAM;IAAEhE,KAAA;IAAO0B;EAAgB,IAAI7C,GAAA;EACnC,OAAOmF,QAAA,CACLtC,eAAA,CAAgBuC,OAAA,CAAQ/H,aAAa,CAAC,GACtC+H,OAAA,CAAQ9H,WAAW,IAAI,GACvB8H,OAAA,CAAQ7H,aAAa,GACrB6H,OAAA,CAAQpH,MAAA,KAAW,IAAImD,KAAA,CAAMiE,OAAA,CAAQ5H,WAAW,CAAC,IAAI,IACvD;AACF;AAKO,SAAS6H,qBACdrF,GAAA,EACAlB,MAAA,EAC4C;EAC5C,MAAM;IAAE3B,MAAA;IAAQkB,IAAA;IAAMkE,MAAA;IAAQ2C;EAAK,IAAIpG,MAAA;EACvC,OAAOwG,iBAAA,CAAkBtF,GAAA,EAAK7C,MAAA,EAAQkB,IAAA,EAAMkE,MAAA,EAAQ2C,IAAA,IAAQtB,oBAAA,EAAsB,KAAK;AACzF;AAKO,SAAS2B,yBAAyBvF,GAAA,EAAelB,MAAA,EAA0C;EAChG,MAAM;IAAE3B,MAAA;IAAQkB,IAAA;IAAMkE,MAAA;IAAQ2C;EAAK,IAAIpG,MAAA;EAEvC,OAAOwG,iBAAA,CAAkBtF,GAAA,EAAK7C,MAAA,EAAQkB,IAAA,EAAMkE,MAAA,EAAQ2C,IAAA,IAAQvB,iBAAA,EAAmB,IAAI;AACrF;AAKO,SAAS6B,YAAYxF,GAAA,EAAeyF,EAAA,EAA0C;EACnF,MAAM5F,OAAA,GAAU+C,eAAA,CAAgB5C,GAAG;EACnC,MAAM;IAAEmB,KAAA;IAAO0B;EAAgB,IAAI7C,GAAA;EAEnC,SAAS/B,CAAA,GAAI,GAAGA,CAAA,GAAI4B,OAAA,CAAQ7B,MAAA,EAAQC,CAAA,IAAK;IACvC,MAAMI,IAAA,GAAOwB,OAAA,CAAQ5B,CAAC;IACtB,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAID,IAAA,CAAKL,MAAA,EAAQM,CAAA,IAAK;MACpC,MAAM4B,GAAA,GAAM7B,IAAA,CAAKC,CAAC;MAElB,MAAMoH,aAAA,GAAgBzH,CAAA,GAAI;MAC1B,MAAM0H,eAAA,GAAkBzF,GAAA,CAAI,CAAC;MAC7B,IAAI/C,MAAA,GAAS;MACb,IAAIoD,YAAA,GAAe;MACnB,IAAIqF,cAAA,GAAiB;MACrB,IAAIC,IAAA,GAAO;MACX,IAAI3F,GAAA,CAAIlC,MAAA,KAAW,GAAG;QACpBb,MAAA,GAAS0F,eAAA,CAAgB3C,GAAA,CAAI,CAAC,CAAC;QAC/BK,YAAA,GAAeL,GAAA,CAAI,CAAC,IAAI;QACxB0F,cAAA,GAAiB1F,GAAA,CAAI,CAAC;MACxB;MACA,IAAIA,GAAA,CAAIlC,MAAA,KAAW,GAAG6H,IAAA,GAAO1E,KAAA,CAAMjB,GAAA,CAAI,CAAC,CAAC;MAEzCuF,EAAA,CAAG;QACDC,aAAA;QACAC,eAAA;QACAxI,MAAA;QACAoD,YAAA;QACAqF,cAAA;QACAC;MACF,CAAgB;IAClB;EACF;AACF;AAEA,SAASC,YAAY9F,GAAA,EAAe7C,MAAA,EAAwB;EAC1D,MAAM;IAAE4C,OAAA;IAAS8C;EAAgB,IAAI7C,GAAA;EACrC,IAAIrD,KAAA,GAAQoD,OAAA,CAAQgG,OAAA,CAAQ5I,MAAM;EAClC,IAAIR,KAAA,KAAU,IAAIA,KAAA,GAAQkG,eAAA,CAAgBkD,OAAA,CAAQ5I,MAAM;EACxD,OAAOR,KAAA;AACT;AAKO,SAASqJ,iBAAiBhG,GAAA,EAAe7C,MAAA,EAA+B;EAC7E,MAAM;IAAE+D;EAAe,IAAIlB,GAAA;EAC3B,IAAIkB,cAAA,IAAkB,MAAM,OAAO;EACnC,MAAMvE,KAAA,GAAQmJ,WAAA,CAAY9F,GAAA,EAAK7C,MAAM;EACrC,OAAOR,KAAA,KAAU,KAAK,OAAOuE,cAAA,CAAevE,KAAK;AACnD;AAKO,SAASsJ,UAAUjG,GAAA,EAAe7C,MAAA,EAAyB;EAChE,MAAM;IAAEiE;EAAW,IAAIpB,GAAA;EACvB,IAAIoB,UAAA,IAAc,MAAM,OAAO;EAC/B,MAAMzE,KAAA,GAAQmJ,WAAA,CAAY9F,GAAA,EAAK7C,MAAM;EACrC,OAAOR,KAAA,KAAU,KAAK,QAAQyE,UAAA,CAAW8E,QAAA,CAASvJ,KAAK;AACzD;AAMO,SAAS+E,oBAAoB1B,GAAA,EAAuBjD,MAAA,EAA2B;EACpF,MAAMoJ,MAAA,GAAS,IAAIlF,QAAA,CAASmF,KAAA,CAAMpG,GAAA,EAAK,EAAE,GAAGjD,MAAM;EAClD2H,IAAA,CAAKyB,MAAM,EAAEhC,QAAA,GAAWnE,GAAA,CAAIpC,QAAA;EAC5B,OAAOuI,MAAA;AACT;AAMO,SAASE,WACdrG,GAAA,EACkF;EAClF,OAAOoG,KAAA,CAAMpG,GAAA,EAAK4C,eAAA,CAAgB5C,GAAG,CAAC;AACxC;AAMO,SAASsG,WAAWtG,GAAA,EAAiC;EAC1D,OAAOoG,KAAA,CAAMpG,GAAA,EAAK2E,eAAA,CAAgB3E,GAAG,CAAC;AACxC;AAEA,SAASoG,MACPpG,GAAA,EACApC,QAAA,EACwD;EACxD,OAAO;IACL4D,OAAA,EAASxB,GAAA,CAAIwB,OAAA;IACbC,IAAA,EAAMzB,GAAA,CAAIyB,IAAA;IACVN,KAAA,EAAOnB,GAAA,CAAImB,KAAA;IACXnE,UAAA,EAAYgD,GAAA,CAAIhD,UAAA;IAChB+C,OAAA,EAASC,GAAA,CAAID,OAAA;IACbmB,cAAA,EAAgBlB,GAAA,CAAIkB,cAAA;IACpBtD,QAAA;IACAwD,UAAA,EAAYpB,GAAA,CAAIoB,UAAA,IAAepB,GAAA,CAAegE;EAChD;AACF;AASA,SAASmB,SACPhI,MAAA,EACAkB,IAAA,EACAkE,MAAA,EACAsD,IAAA,EAC0C;EAC1C,OAAO;IAAE1I,MAAA;IAAQkB,IAAA;IAAMkE,MAAA;IAAQsD;EAAK;AACtC;AAIA,SAASU,SACPlI,IAAA,EACAkE,MAAA,EAC4C;EAC5C,OAAO;IAAElE,IAAA;IAAMkE;EAAO;AACxB;AAgBA,SAASyC,qBACPD,QAAA,EACAvE,IAAA,EACAnC,IAAA,EACAkE,MAAA,EACA2C,IAAA,EACQ;EACR,IAAIvI,KAAA,GAAQ8C,oBAAA,CAAqBsF,QAAA,EAAUxC,MAAA,EAAQ/B,IAAA,EAAMnC,IAAI;EAC7D,IAAIM,KAAA,EAAS;IACXhC,KAAA,IAASuI,IAAA,KAASvB,iBAAA,GAAoBxE,UAAA,GAAaC,UAAA,EAAY2F,QAAA,EAAUxC,MAAA,EAAQ5F,KAAK;EACxF,WAAWuI,IAAA,KAASvB,iBAAA,EAAmBhH,KAAA;EAEvC,IAAIA,KAAA,KAAU,MAAMA,KAAA,KAAUoI,QAAA,CAAS/G,MAAA,EAAQ,OAAO;EACtD,OAAOrB,KAAA;AACT;AAEA,SAAS6J,wBACPzB,QAAA,EACAvE,IAAA,EACAnC,IAAA,EACAkE,MAAA,EACA2C,IAAA,EACoB;EACpB,IAAI5C,GAAA,GAAM0C,oBAAA,CAAqBD,QAAA,EAAUvE,IAAA,EAAMnC,IAAA,EAAMkE,MAAA,EAAQqB,oBAAoB;EAQjF,IAAI,CAACjF,KAAA,IAAWuG,IAAA,KAASvB,iBAAA,EAAmBrB,GAAA;EAE5C,IAAIA,GAAA,KAAQ,MAAMA,GAAA,KAAQyC,QAAA,CAAS/G,MAAA,EAAQ,OAAO,EAAC;EAKnD,MAAMyI,aAAA,GAAgB9H,KAAA,GAAU4D,MAAA,GAASwC,QAAA,CAASzC,GAAG,EAAElF,MAAM;EAG7D,IAAI,CAACuB,KAAA,EAAS2D,GAAA,GAAMlD,UAAA,CAAW2F,QAAA,EAAU0B,aAAA,EAAenE,GAAG;EAC3D,MAAMoE,GAAA,GAAMvH,UAAA,CAAW4F,QAAA,EAAU0B,aAAA,EAAenE,GAAG;EAEnD,MAAMqE,MAAA,GAAS,EAAC;EAChB,OAAOrE,GAAA,IAAOoE,GAAA,EAAKpE,GAAA,IAAO;IACxB,MAAM8C,OAAA,GAAUL,QAAA,CAASzC,GAAG;IAC5BqE,MAAA,CAAO1D,IAAA,CAAKsD,QAAA,CAASnB,OAAA,CAAQ3H,kBAAkB,IAAI,GAAG2H,OAAA,CAAQ1H,oBAAoB,CAAC,CAAC;EACtF;EACA,OAAOiJ,MAAA;AACT;AAkBA,SAASrB,kBACPtF,GAAA,EACA7C,MAAA,EACAkB,IAAA,EACAkE,MAAA,EACA2C,IAAA,EACA0B,GAAA,EACiE;EA5dnE,IAAAhC,EAAA;EA6dEvG,IAAA;EACA,IAAIA,IAAA,GAAO,GAAG,MAAM,IAAIiG,KAAA,CAAMb,aAAa;EAC3C,IAAIlB,MAAA,GAAS,GAAG,MAAM,IAAI+B,KAAA,CAAMZ,eAAe;EAE/C,MAAM;IAAE3D,OAAA;IAAS8C;EAAgB,IAAI7C,GAAA;EACrC,IAAIG,YAAA,GAAcJ,OAAA,CAAQgG,OAAA,CAAQ5I,MAAM;EACxC,IAAIgD,YAAA,KAAgB,IAAIA,YAAA,GAAc0C,eAAA,CAAgBkD,OAAA,CAAQ5I,MAAM;EACpE,IAAIgD,YAAA,KAAgB,IAAI,OAAOyG,GAAA,GAAM,EAAC,GAAIL,QAAA,CAAS,MAAM,IAAI;EAE7D,MAAMM,SAAA,IAAajC,EAAA,GAAAF,IAAA,CAAK1E,GAAG,GAAEwE,UAAA,KAAVI,EAAA,CAAUJ,UAAA,GAAe5E,cAAA,CAC1CgD,eAAA,CAAgB5C,GAAG,GAClB0E,IAAA,CAAK1E,GAAG,EAAEyE,cAAA,GAAiB1E,OAAA,CAAQC,GAAA,CAAIX,aAAa,CACvD;EAEA,MAAM0F,QAAA,GAAW8B,SAAA,CAAU1G,YAAW,EAAE9B,IAAI;EAC5C,IAAI0G,QAAA,IAAY,MAAM,OAAO6B,GAAA,GAAM,EAAC,GAAIL,QAAA,CAAS,MAAM,IAAI;EAE3D,MAAM/F,IAAA,GAAOkE,IAAA,CAAK1E,GAAG,EAAEyE,cAAA,CAAgBtE,YAAW;EAElD,IAAIyG,GAAA,EAAK,OAAOJ,uBAAA,CAAwBzB,QAAA,EAAUvE,IAAA,EAAMnC,IAAA,EAAMkE,MAAA,EAAQ2C,IAAI;EAE1E,MAAMvI,KAAA,GAAQqI,oBAAA,CAAqBD,QAAA,EAAUvE,IAAA,EAAMnC,IAAA,EAAMkE,MAAA,EAAQ2C,IAAI;EACrE,IAAIvI,KAAA,KAAU,IAAI,OAAO4J,QAAA,CAAS,MAAM,IAAI;EAE5C,MAAMnB,OAAA,GAAUL,QAAA,CAASpI,KAAK;EAC9B,OAAO4J,QAAA,CAASnB,OAAA,CAAQ3H,kBAAkB,IAAI,GAAG2H,OAAA,CAAQ1H,oBAAoB,CAAC;AAChF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}