{"ast":null,"code":"// src/set-array.ts\nvar SetArray = class {\n  constructor() {\n    this._indexes = {\n      __proto__: null\n    };\n    this.array = [];\n  }\n};\nfunction cast(set) {\n  return set;\n}\nfunction get(setarr, key) {\n  return cast(setarr)._indexes[key];\n}\nfunction put(setarr, key) {\n  const index = get(setarr, key);\n  if (index !== void 0) return index;\n  const {\n    array,\n    _indexes: indexes\n  } = cast(setarr);\n  const length = array.push(key);\n  return indexes[key] = length - 1;\n}\nfunction remove(setarr, key) {\n  const index = get(setarr, key);\n  if (index === void 0) return;\n  const {\n    array,\n    _indexes: indexes\n  } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]--;\n  }\n  indexes[key] = void 0;\n  array.pop();\n}\n\n// src/gen-mapping.ts\nimport { encode } from \"@jridgewell/sourcemap-codec\";\nimport { TraceMap, decodedMappings } from \"@jridgewell/trace-mapping\";\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/gen-mapping.ts\nvar NO_NAME = -1;\nvar GenMapping = class {\n  constructor({\n    file,\n    sourceRoot\n  } = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n};\nfunction cast2(map) {\n  return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n}\nfunction addMapping(map, mapping) {\n  return addMappingInternal(false, map, mapping);\n}\nvar maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n  return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n};\nvar maybeAddMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping);\n};\nfunction setSourceContent(map, source, content) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);else remove(ignoreList, index);\n}\nfunction toDecodedMap(map) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast2(map);\n  removeEmptyFinalLines(mappings);\n  return {\n    version: 3,\n    file: map.file || void 0,\n    names: names.array,\n    sourceRoot: map.sourceRoot || void 0,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array\n  };\n}\nfunction toEncodedMap(map) {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: encode(decoded.mappings)\n  });\n}\nfunction fromMap(input) {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({\n    file: map.file,\n    sourceRoot: map.sourceRoot\n  });\n  putAll(cast2(gen)._names, map.names);\n  putAll(cast2(gen)._sources, map.sources);\n  cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast2(gen)._mappings = decodedMappings(map);\n  if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);\n  return gen;\n}\nfunction allMappings(map) {\n  const out = [];\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _names: names\n  } = cast2(map);\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generated = {\n        line: i + 1,\n        column: seg[COLUMN]\n      };\n      let source = void 0;\n      let original = void 0;\n      let name = void 0;\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = {\n          line: seg[SOURCE_LINE] + 1,\n          column: seg[SOURCE_COLUMN]\n        };\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n      out.push({\n        generated,\n        source,\n        original,\n        name\n      });\n    }\n  }\n  return out;\n}\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n  assert(sourceLine);\n  assert(sourceColumn);\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n  return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n}\nfunction assert(_val) {}\nfunction getIndex(arr, index) {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\nfunction getColumnIndex(line, genColumn) {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n  const {\n    length\n  } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\nfunction putAll(setarr, array) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n  if (index === 0) return true;\n  const prev = line[index - 1];\n  return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  if (index === 0) return false;\n  const prev = line[index - 1];\n  if (prev.length === 1) return false;\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n  const {\n    generated,\n    source,\n    original,\n    name,\n    content\n  } = mapping;\n  if (!source) {\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n  }\n  assert(original);\n  return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n}\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setIgnore, setSourceContent, toDecodedMap, toEncodedMap };","map":{"version":3,"names":["SetArray","constructor","_indexes","__proto__","array","cast","set","get","setarr","key","put","index","indexes","length","push","remove","i","k","pop","encode","TraceMap","decodedMappings","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","NO_NAME","GenMapping","file","sourceRoot","_names","_sources","_sourcesContent","_mappings","_ignoreList","cast2","map","addSegment","genLine","genColumn","source","sourceLine","sourceColumn","name","content","addSegmentInternal","addMapping","mapping","addMappingInternal","maybeAddSegment","maybeAddMapping","setSourceContent","sources","sourcesContent","setIgnore","ignore","ignoreList","toDecodedMap","mappings","names","removeEmptyFinalLines","version","toEncodedMap","decoded","Object","assign","fromMap","input","gen","putAll","allMappings","out","line","j","seg","generated","column","original","skipable","getIndex","getColumnIndex","skipSourceless","insert","assert","sourcesIndex","namesIndex","skipSource","_val","arr","current","value","len","prev"],"sources":["E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\gen-mapping\\src\\set-array.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\gen-mapping\\src\\gen-mapping.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\gen-mapping\\src\\sourcemap-segment.ts"],"sourcesContent":["type Key = string | number | symbol;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray<T extends Key = Key> {\n  declare private _indexes: Record<T, number | undefined>;\n  declare array: readonly T[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n}\n\ninterface PublicSet<T extends Key> {\n  array: T[];\n  _indexes: SetArray<T>['_indexes'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\n  return set as any;\n}\n\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\n  return cast(setarr)._indexes[key];\n}\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n\n  const { array, _indexes: indexes } = cast(setarr);\n\n  const length = array.push(key);\n  return (indexes[key] = length - 1);\n}\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\n  const { array, _indexes: indexes } = cast(setarr);\n  if (array.length === 0) return;\n\n  const last = array.pop()!;\n  indexes[last] = undefined;\n}\n\n/**\n * Removes the key, if it exists in the set.\n */\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]!--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\n","import { SetArray, put, remove } from './set-array';\nimport {\n  encode,\n  // encodeGeneratedRanges,\n  // encodeOriginalScopes\n} from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\n// import type { OriginalScope, GeneratedRange } from '@jridgewell/sourcemap-codec';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type {\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Pos,\n  Mapping,\n  // BindingExpressionRange,\n  // OriginalPos,\n  // OriginalScopeInfo,\n  // GeneratedRangeInfo,\n} from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  declare private _names: SetArray<string>;\n  declare private _sources: SetArray<string>;\n  declare private _sourcesContent: (string | null)[];\n  declare private _mappings: SourceMapSegment[][];\n  // private declare _originalScopes: OriginalScope[][];\n  // private declare _generatedRanges: GeneratedRange[];\n  declare private _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    // this._originalScopes = [];\n    // this._generatedRanges = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  // _originalScopes: GenMapping['_originalScopes'];\n  // _generatedRanges: GenMapping['_generatedRanges'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n  // if (index === originalScopes.length) originalScopes[index] = [];\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  // if (index === originalScopes.length) originalScopes[index] = [];\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  });\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  // TODO: implement originalScopes/generatedRanges\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n  // if (sourcesIndex === originalScopes.length) originalScopes[sourcesIndex] = [];\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getIndex<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n\n/*\nexport function addOriginalScope(\n  map: GenMapping,\n  data: {\n    start: Pos;\n    end: Pos;\n    source: string;\n    kind: string;\n    name?: string;\n    variables?: string[];\n  },\n): OriginalScopeInfo {\n  const { start, end, source, kind, name, variables } = data;\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _originalScopes: originalScopes,\n    _names: names,\n  } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (index === originalScopes.length) originalScopes[index] = [];\n\n  const kindIndex = put(names, kind);\n  const scope: OriginalScope = name\n    ? [start.line - 1, start.column, end.line - 1, end.column, kindIndex, put(names, name)]\n    : [start.line - 1, start.column, end.line - 1, end.column, kindIndex];\n  if (variables) {\n    scope.vars = variables.map((v) => put(names, v));\n  }\n  const len = originalScopes[index].push(scope);\n  return [index, len - 1, variables];\n}\n*/\n\n// Generated Ranges\n/*\nexport function addGeneratedRange(\n  map: GenMapping,\n  data: {\n    start: Pos;\n    isScope: boolean;\n    originalScope?: OriginalScopeInfo;\n    callsite?: OriginalPos;\n  },\n): GeneratedRangeInfo {\n  const { start, isScope, originalScope, callsite } = data;\n  const {\n    _originalScopes: originalScopes,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _generatedRanges: generatedRanges,\n  } = cast(map);\n\n  const range: GeneratedRange = [\n    start.line - 1,\n    start.column,\n    0,\n    0,\n    originalScope ? originalScope[0] : -1,\n    originalScope ? originalScope[1] : -1,\n  ];\n  if (originalScope?.[2]) {\n    range.bindings = originalScope[2].map(() => [[-1]]);\n  }\n  if (callsite) {\n    const index = put(sources, callsite.source);\n    if (index === sourcesContent.length) sourcesContent[index] = null;\n    if (index === originalScopes.length) originalScopes[index] = [];\n    range.callsite = [index, callsite.line - 1, callsite.column];\n  }\n  if (isScope) range.isScope = true;\n  generatedRanges.push(range);\n\n  return [range, originalScope?.[2]];\n}\n\nexport function setEndPosition(range: GeneratedRangeInfo, pos: Pos) {\n  range[0][2] = pos.line - 1;\n  range[0][3] = pos.column;\n}\n\nexport function addBinding(\n  map: GenMapping,\n  range: GeneratedRangeInfo,\n  variable: string,\n  expression: string | BindingExpressionRange,\n) {\n  const { _names: names } = cast(map);\n  const bindings = (range[0].bindings ||= []);\n  const vars = range[1];\n\n  const index = vars!.indexOf(variable);\n  const binding = getIndex(bindings, index);\n\n  if (typeof expression === 'string') binding[0] = [put(names, expression)];\n  else {\n    const { start } = expression;\n    binding.push([put(names, expression.expression), start.line - 1, start.column]);\n  }\n}\n*/\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}