{"ast":null,"code":"// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const {\n      buffer\n    } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const {\n      buffer,\n      out,\n      pos\n    } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const {\n      buffer,\n      pos\n    } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const {\n    length\n  } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length;) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    4: kind,\n    vars\n  } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length;) {\n    const next = scopes[index];\n    const {\n      0: l,\n      1: c\n    } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const {\n    length\n  } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length;) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const {\n      4: sourcesIndex,\n      5: scopesIndex\n    } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const {\n      0: sourcesIndex,\n      1: callLine,\n      2: callColumn\n    } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length;) {\n    const next = ranges[index];\n    const {\n      0: l,\n      1: c\n    } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const {\n    length\n  } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\nexport { decode, decodeGeneratedRanges, decodeOriginalScopes, encode, encodeGeneratedRanges, encodeOriginalScopes };","map":{"version":3,"names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInt","i","length","c","decodeInteger","reader","relative","value","shift","integer","next","shouldNegate","encodeInteger","builder","num","delta","clamped","write","hasMoreVlq","max","pos","peek","bufLength","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","StringWriter","constructor","v","flush","subarray","StringReader","indexOf","char","idx","EMPTY","decodeOriginalScopes","input","scopes","stack","line","column","last","pop","kind","fields","hasName","scope","vars","varsIndex","push","encodeOriginalScopes","writer","_encodeOriginalScopes","index","state","startLine","startColumn","endLine","endColumn","l","decodeGeneratedRanges","ranges","genLine","definitionSourcesIndex","definitionScopeIndex","callsiteSourcesIndex","callsiteLine","callsiteColumn","bindingLine","bindingColumn","semi","genColumn","hasDefinition","hasCallsite","hasScope","callsite","bindings","range","defSourcesIndex","isScope","prevCsi","prevLine","sameSource","expressionsCount","expressionRanges","prevBl","expression","encodeGeneratedRanges","_encodeGeneratedRanges","catchupLine","sourcesIndex","scopesIndex","callLine","callColumn","binding","bindingStartLine","bindingStartColumn","expRange","lastLine","mappings","decoded","sourceLine","sourceColumn","namesIndex","sorted","lastCol","seg","sort","sortComparator","a","b","encode","j","segment"],"sources":["E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\sourcemap-codec\\src\\vlq.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\sourcemap-codec\\src\\strings.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\sourcemap-codec\\src\\scopes.ts","E:\\web\\portfolio-frontend\\node_modules\\@jridgewell\\sourcemap-codec\\src\\sourcemap-codec.ts"],"sourcesContent":["import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n","const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n","import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n","import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}